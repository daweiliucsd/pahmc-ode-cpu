# -*- coding: utf-8 -*-
"""
@author: Zheng Fang

This is the core of pahmc_ode_cpu. It receives all the user-provided specs from
'main.py' as well as the data generated by 'data_preparation.py', and perform 
the PAHMC algorithm for state and parameter estimation.
"""


import numpy as np


class Core:
	"""
	Below is an implementation of the Precision Annealing Hamiltonian Monte 
	Carlo methods. HMC is called from 'pahmc'. Note that functions to evaluate 
	the action, A(X), and its derivatives are in a different class.
	"""

	def __init__(self):
		"""The name of the dynamics is included below in 'dyn'."""

	def pa(self, dyn, 
		   data_noisy, D, dt, M, obsdim, 
		   Rf0, alpha, betamax, 
		   n_iter, epsilon, S, mass, scaling, 
		   par_specs, soft_dynrange, 
		   Rm=1.0, burn=0.5):
		"""
		This method does Precision Annealing using Hamiltonian Monte Carlo as
		a sampler/optimizer.

		Inputs
		------
		          dyn: an object instantiated using 'def_dynamics.Dynamics'.
		   data_noisy: D-by-length numpy array containing the noisy training 
		   			   data.
		            D: model degrees of freedom.
		           dt: discretization interval.
		            M: number of time steps actually being used to train the 
		               model.
		       obsdim: Python list containing the observed dimensions chosen 
		               from the set {1, ..., D}.
		          Rf0: the starting Rf for precision annealing.
		        alpha: Rf = Rf0 * (alpha ** beta).
		      betamax: maximum beta value.
		       n_iter: int or a Python list of length betamax. When an integer 
					   input is given, n_iter will be broadcasted into a list 
					   of length betamax; when a list is given, n_iter remains 
					   itself.
		      epsilon: float or a Python list of length betamax. When a float 
					   input is given, epsilon will be broadcasted into a list
					   of length betamax; when a list is given, epsilon remains 
					   itself.
		            S: int or a Python list of length betamax. When an integer
					   input is given, S will be broadcasted into a list of 
					   length betamax; when a list is given, S remains itself.
		         mass: float or a Python list of length betamax. When a float 
					   input is given, mass will be broadcasted into a list of 
					   length betamax; when a list is given, mass remains 
					   itself.
		      scaling: float or a Python list of length betamax. When a float 
					   input is given, scaling will be broadcasted into a list 
					   of length betamax; when a list is given, scaling remains 
					   itself.
		    par_specs: a Python (3.7) dictionary with each entry being either 
					   an int or a Python tuple of (start, lower, upper). When
					   an entry is an integer, the corresponding parameter is
					   given np.inf and - np.inf as the upper and lower bounds,
					   respectively. Note that these bounds are "hard".
		soft_dynrange: a Python tuple of (low, high) or a list of length D with
					   each element being such a tuple. It gives a soft range
					   for the dynamic initialization process.

		Returns:
		--------
		     acceptance: numpy array of length betamax.
		         action: 2D numpy array.
		action_meanpath: numpy array of length betamax.
		           burn: proportion of HMC samples thrown away at each beta.
			FE_meanpath: numpy array of length betamax.
			ME_meanpath: numpy array of length betamax.
			   par_init: numpy array of length betamax; each element in the 
			   			 array is a Python (3.7) dictionary.
			par_history: 2D numpy array; each element in the array is a Python
						 (3.7) dictionary.
			   par_mean: numpy array of length betamax; each element in the 
			   			 array is a Python (3.7) dictionary.
					 Rf: numpy array of length betamax.
					 Rm: scalar.
				 X_init: betamax-by-D-by-M numpy array.
				 X_mean: betamax-by-D-by-M numpy array.
		 Xfinal_history: 3D numpy array.
		"""
		print(1)
		return
